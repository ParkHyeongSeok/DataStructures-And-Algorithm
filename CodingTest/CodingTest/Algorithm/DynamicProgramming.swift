//
//  DynamicProgramming.swift
//  CodingTest
//
//  Created by 박형석 on 2021/08/13.
//

import Foundation

struct DynamicProgramming {
    // 동적 계획법,
    // 일반적인 프로그래밍 분야에서 "동적"의미는? 자료구조에서 '동적 할당'은 프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법을 의미..
    // 반면 다이나믹 프로그래밍에서는... 별 의미없음
    // 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법
    // 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장! -> 다시 읽지 않도록 한다.
    // 완전 탐색을 이용한 비효율적인 시간 복잡도를 가진 문제라도 다이나믹 프로그래밍을 이용해서 시간 복잡도를 획기적으로 줄일 수 있다.
    
    // 구현은 탑다운(하향식), 바텀업(상향식)으로 구성
    
    // 다이나믹 프로그래밍 사용 조건
    // 1. 최적 부분 구조(Optimal Substructure) : 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있을 때
    // 2. 중복되는 부분 문제(Overlapping Subproblem) : 동일한 작은 문제를 반복적으로 해결해야 할 때
    
    // 예시. 피보나치 수열
    // 점화식? 인접한 항들 사이의 관계식을 의미한다.
    // An = An-1 + An-2, A1 = 1, A2 = 1 (피보나치 수열 점화식)
    // 점화식은 재귀함수로 구현할 수 있다!
    
    // 다이나믹 프로그래밍에서 어떤 결과를 저장하기 위해서 배열이나 리스트를 사용, 테이블이라고 부르기도 한다.
    
    func fibo(_ x: Int) -> Int {
        if x == 1 || x == 2 {
            return 1
        }
        return fibo(x-1) + fibo(x-2)
    }
    
    // 이렇게 하면 O(2N) -> 기하급수적으로 올라감 30은 10억...연산
    // 중복되는 부분 문제가 발생하기 때문에 다이나믹 프로그래밍 사용, 한번 해결한 문제를 기록해놓고 알려주는 방식
    
    // 구현방법1 : 하향식, 탑다운 방법 => 메모이제이션
    // 한 번 계산한 결과를 메모리 공간에 메모, 같은 문제를 호출하면 메모했던 결과를 그대로 가져온다. 값을 기록해 놓는다는 점에서 캐싱
    // 구현과정에서 재귀함수를 이용한다. 큰 문제를 해결하기 위해서 작은 문제들을 재귀적으로 호출해서 그 문제가 해결되면 큰 문제를 해결하도록 작성, 그 과정에서 작은 문제들의 해결값을 메모이제이션 기법을 이용
    
    // 구현방법2: 상향식, 바텀업 방법 => 이게 전형적인 형태
    // 먼저 계산했던 문제의 값을 활용해서 그 다음의 문제를 차례로 해결.
    // 반복문을 이용. 여기서 사용하는 저장용 리스트는 DP 테이블이라고 부른다. (배열 혹은 리스트를 그렇게 부름)
    
    var dp = Array(0...99)
    
    // 탑다운 재귀함수 O(N)
    mutating func fiboTopDown(_ x: Int) -> Int {
        if x == 1 || x == 2 {
            return 1
        }
        
        if dp[x] != 0 {
            return dp[x]
        }
        
        dp[x] = fibo(x-1) + fibo(x-2)

        return dp[x]
    }
    
    // 바텀업 반복문 O(N)
    mutating func fivoBottonUp() {
        // 이거 원래는 밖에 있어야 해
        dp[1] = 1
        dp[2] = 1
        let n = 99
        
        // 작은 문제(3)부터 해결하고 저장한뒤에 다음 계산에 중복된게 있으면 넣는 방식
        for i in 3...n+1 {
            dp[i] = dp[i-1] + dp[i-2]
        }
    }
    
    // 다이나믹 프로그래밍 vs 분할정복
    // 공통점 : 최적 부분 구조 (큰 문제를 작은 문제로 나눌 수 있고 작은 문제의 답을 모아 큰 문제를 해결할 수 있는 상황)
    // 차이점 : 부분 문제의 중복되는가? (다이나믹 "Yes!")
    // 다이나믹 프로그래밍 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복
    // 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않는다.
    // 퀵정렬(분할 정복)의 경우 피벗값을 기준으로 분할이 이뤄진 후에 피벗값은 다른 부분 문제에 포함되지 않고 위치가 변경되지 않기 때문에 문제가 중복되지 않는다. 병합 정렬과 같은 분할 정복도 마찬가지다.
    
    /*
     어떻게 보다 쉽게 해결할 수 있을까?
     
     1. 주어진 문제가 다이나믹 프로그래밍 유형인지 파악
     2. 가장 먼저 그리디, 구현, 완전 탐색 등의 아이디어로 해결할 수 있는지 검토(너무 많은 시간 복잡도가 예상되면). 아니라면 다이나믹 프로그래밍으로 가능한지 고민
     3. 일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤, 작은 문제에서 구한 답이 큰 문제에 그대로 사용될 수 있으면, 코드를 개선하는 방법(한번 계산한 결과를 메모이제이션 기법을 통해 저장 불러오기)을 사용할 수 있다.
     4. 일반적인 코딩 테스트 수준에서는 기본 유형의 다이나믹 프로그래밍 문제가 출제 (점화식을 떠올리기가 어렵기 때문)
     */
    
}
